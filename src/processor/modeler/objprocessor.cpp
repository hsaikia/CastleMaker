#include "objprocessor.h"
#include <iostream>
#include <map>
#include <algorithm>

extern std::map <std::string, Material > material_map;
extern std::string DATA_DIR;

bool compare_faces(Face f1, Face f2){
    if(f1.material < f2.material) 
	return true;
    return false;
}

void writeMtl(const char* filename, std::vector<std::string> materials){
    std::ofstream f;
    char filename_mtl[256];
    sprintf(filename_mtl, "%s.mtl", filename);
    f.open(filename_mtl);
    for(std::map<std::string, Material>::iterator it = material_map.begin(); it != material_map.end(); it++){
	if(it->first == "") continue;
	f << "\n\nnewmtl " << it->first;
	f << "\nKa " << it->second.Ka.x << " " << it->second.Ka.y << " " << it->second.Ka.z;
	f << "\nKd " << it->second.Kd.x << " " << it->second.Kd.y << " " << it->second.Kd.z;
	if(it->second.map_Ka != ""){
	    f << "\nmap_Ka " << it->second.map_Ka;
	}
	if(it->second.map_Kd != ""){
	    f << "\nmap_Kd " << it->second.map_Kd;
	}
    }
    f.close();
}

void sortFacesByMaterial(Model& model){
    //Sort the faces according to material
    std::sort(model.faces.begin(), model.faces.end(), compare_faces);
}

void writeObj(const char* filename, Model model) {
    //printf("Filename is %s\n", filename);
    sortFacesByMaterial(model);
    std::string curr_material = "";
    std::ofstream f;
    char filename_obj[256];
    sprintf(filename_obj, "%s.obj", filename);
    f.open(filename_obj);
    f << "# This file is generated by the procedural modelling tool for castles.\n# Author : Himangshu Saikia\n# Email : arctic.quasar@gmail.com\n";
    f << "mtllib " << filename << ".mtl" << "\n";
    f << "# Vertices\n";
    int vertices = 0;
    int texcos = 0;
    int face_start = 0;
    int face_end = 0;
    std::vector<std::string> materials;
    for(int i=0; i<model.faces.size(); i++) {
	if(model.faces[i].material != curr_material){
	    for(int j = face_start; j < face_end; j++){
		f << "f";
		for(int k = 0; k < model.faces[j].vertex_indices.size(); k++) {
		    f << " " << model.faces[j].vertex_indices[k] + 1;
		    if(model.faces[j].texture_indices.size() > k){
			f << "/" << model.faces[j].texture_indices[k] + 1;
		    }
		}
		f << "\n";
	    }
	    face_start = face_end;
	    curr_material = model.faces[i].material;
	    materials.push_back(curr_material);
	    f << "usemtl " << curr_material << "\n";
	    i--;
	} else {
	    face_end++;
	    for(int j = 0; j < model.faces[i].vertex_indices.size(); j++){
		f << "v ";
		f<< model.vertices[model.faces[i].vertex_indices[j]].x << " ";
		f<< model.vertices[model.faces[i].vertex_indices[j]].y << " ";
		f<< model.vertices[model.faces[i].vertex_indices[j]].z << "\n";
		model.faces[i].vertex_indices[j] = vertices;
		vertices++;
	    }
	    for(int j = 0; j < model.faces[i].texture_indices.size(); j++){
		f << "vt ";
		f<< model.tex_coords[model.faces[i].texture_indices[j]].x << " ";
		f<< model.tex_coords[model.faces[i].texture_indices[j]].y << " ";
		f<< model.tex_coords[model.faces[i].texture_indices[j]].z << "\n";
		model.faces[i].texture_indices[j] = texcos;
		texcos++;
	    }
	}
    }
    f << "# Faces\n";
    for(int j = face_start; j < face_end; j++){
	f << "f";
	for(int k = 0; k < model.faces[j].vertex_indices.size(); k++) {
	    f << " " << model.faces[j].vertex_indices[k] + 1;
	    if(model.faces[j].texture_indices.size() > k){
		f << "/" << model.faces[j].texture_indices[k] + 1;
	    }
	}
	f << "\n";
    }
    writeMtl(filename, materials);
    f.close();
}

void readMtl(std::string filename, bool areMaterialsLocal) {
    //printf("mtl file : %s\n", filename.c_str());
    std::ifstream f;
    std::string file_path = DATA_DIR + filename;
    f.open(file_path.c_str());
    if(!f.is_open()) {
        printf("Error! Material Filename %s is invalid! Set DATA_DIR in main\n", filename.c_str());
        //exit(1);
    } else {
        //printf("Everything fine, proceeding... [filename %s]\n", filename);
    }
    std::string line;
    std::string curr_mat = "";
    Material mat;
    while(getline(f, line)) {
	if(line == "") continue;
	//printf("LINE IS |%s|\n", line.c_str());
        trim(line);
        std::vector<std::string> toks;
        split_del(line, toks, ' ');
        if(toks[0] == "newmtl") {
	    if(material_map.find(curr_mat) == material_map.end())
		material_map[curr_mat] = mat;
	    if(areMaterialsLocal)
		curr_mat = filename + "_" + toks[1];
	    else
		curr_mat = toks[1];
        } else if(toks[0] == "Ka") {
            Point p(atof(toks[1].c_str()), atof(toks[2].c_str()), atof(toks[3].c_str()));
            mat.Ka = p;
        } else if(toks[0] == "Kd") {
            Point p(atof(toks[1].c_str()), atof(toks[2].c_str()), atof(toks[3].c_str()));
            mat.Kd = p;
        } else if(toks[0] == "map_Ka") {    
	    if(toks.size() > 1)
	    mat.map_Ka = toks[1];
        } else if(toks[0] == "map_Kd") {
	    if(toks.size() > 1)
	    mat.map_Kd = toks[1];
	}
    }
    if(material_map.find(curr_mat) == material_map.end())
	material_map[curr_mat] = mat;
}

void readObj(const char* filename, Model& model, bool areMaterialsLocal) {
    std::ifstream f;
    std::string file_path = DATA_DIR + std::string(filename);
    f.open(file_path.c_str());
    if(!f.is_open()) {
        printf("Error! Filename %s is invalid! Set DATA_DIR in main.\n", filename);
        //exit(1);
    } else {
        //printf("Everything fine, proceeding... [filename %s]\n", filename);
    }
    std::string line;
    std::string material_file = "";
    std::string curr_material = "default";
    while(getline(f, line)) {
	if(line == "") continue;
        //std::cout<<"[" << line << "]" <<std::endl;
        trim(line);
        //std::cout<<"[" << line << "]" <<std::endl;
        std::vector<std::string> toks;
        split_del(line, toks, ' ');
        //if(toks[0][0] == '#'){
        //	continue;
        //}
        if(toks[0] == "mtllib") {
            material_file = toks[1];
            readMtl(toks[1], areMaterialsLocal);
        } else if(toks[0] == "usemtl") {
	    if(areMaterialsLocal)
		curr_material = material_file + "_" + toks[1];
	    else
		curr_material = toks[1];
		
        } else if(toks[0] == "v") {
            //printf("encountered vertex!\n");
            Point p(atof(toks[1].c_str()), atof(toks[2].c_str()), atof(toks[3].c_str()));
            model.vertices.push_back(p);
        } else if (toks[0] == "vt") {
            float u, v = 0, w = 0;
            u = atof(toks[1].c_str());
            if(toks.size() > 2)
                v = atof(toks[2].c_str());
            if(toks.size() > 3)
                w = atof(toks[3].c_str());
            Point p(u, v, w);
            model.tex_coords.push_back(p);
        } else if (toks[0] == "vn") {
            //Point p(atof(toks[1].c_str()), atof(toks[2].c_str()), atof(toks[3].c_str()));
            //model.normals.push_back(p);
        } else if(toks[0] == "f") {
            //printf("encountered face!\n");
            Face face;
            face.material = curr_material;
            for(int i = 1; i<toks.size(); i++) {
                std::vector<std::string> subtoks;
                split_del(toks[i], subtoks, '/');
                face.vertex_indices.push_back(atoi(subtoks[0].c_str()) - 1);
                if(subtoks.size() > 1 && subtoks[1] != "")
                    face.texture_indices.push_back(atoi(subtoks[1].c_str()) - 1);
                //if(subtoks.size() > 2 && subtoks[2] != "")
                //    face.normal_indices.push_back(atoi(subtoks[2].c_str()) - 1);
            }
            model.faces.push_back(face);
        }
    }
}

